# Filigree-Next: Workflow Extensibility Design

**Date**: 2026-02-25
**Status**: Proposed
**Source**: Multi-agent facilitated discussion (5 rounds, 6 specialist agents)
**Transcript**: [2026-02-25-workflow-discussion-transcript.md](./2026-02-25-workflow-discussion-transcript.md)
**Review**: [2026-02-25-workflow-review-annex.md](./2026-02-25-workflow-review-annex.md)
**Compatibility**: Clean break — no backwards compatibility with filigree v1.x

---

## Executive Summary

Filigree-next replaces the current schema with a unified relationship model that is fully domain-agnostic. Two core tables (`items` + `item_links`) replace the current `issues` table (with its `parent_id` column) and `dependencies` table. All relationships — hierarchy, blocking, container assignment — are typed links governed by the template registry. Workflow packs define domain-specific types, states, transitions, link rules, and visual metadata. A Content Publishing (editorial) pack ships as the exemplar non-programming workflow.

### Key Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Base entity name | "item" (not "issue") | Domain-neutral; "issue" implies defect |
| Relationship model | Unified `item_links` table | Replaces parent_id + dependencies + container assignments |
| Container roles | Goal / Cycle / Stream (universal) | Maps across software, publishing, clinical, construction, grants |
| Cardinality | "At most one" per container role | Prevents accountability diffusion; Tragedy of the Commons avoidance |
| ON DELETE | RESTRICT | Silent data loss is unacceptable; explicit unlink-then-delete |
| Time awareness | `due_at` column + dashboard warnings | No auto-transitions; no daemon architecture |
| UX model | Progressive Structure | Sections appear as containers are created |
| Unassigned work | Three-tier Andon Cord | Panel → nudge → hard gate at close |
| View system | Bounded menu (list/kanban/calendar/timeline) | Pack-declared defaults, no arbitrary widget API |

---

## 1. Core Schema

### 1.1 Items Table

```sql
CREATE TABLE items (
    id          TEXT PRIMARY KEY,
    title       TEXT NOT NULL,
    description TEXT DEFAULT '',
    notes       TEXT DEFAULT '',
    type        TEXT NOT NULL,                          -- pack-defined, no default
    status      TEXT NOT NULL,                          -- state machine governed
    priority    INTEGER NOT NULL DEFAULT 2 CHECK (priority BETWEEN 0 AND 4),
    assignee    TEXT DEFAULT '',
    created_by  TEXT DEFAULT '',                        -- who created this item
    due_at      TEXT,                                   -- optional deadline (ISO 8601 UTC, e.g. '2026-03-15T00:00:00Z')
    created_at  TEXT NOT NULL,
    updated_at  TEXT NOT NULL,
    closed_at   TEXT,
    fields      TEXT DEFAULT '{}'                       -- JSON: pack-defined custom fields
);

CREATE INDEX ix_items_status ON items(status);
CREATE INDEX ix_items_type_status ON items(type, status);
CREATE INDEX ix_items_assignee ON items(assignee);
CREATE INDEX ix_items_due ON items(due_at) WHERE due_at IS NOT NULL;
```

### 1.2 Item Links Table

```sql
CREATE TABLE item_links (
    source_id   TEXT NOT NULL REFERENCES items(id) ON DELETE RESTRICT,
    target_id   TEXT NOT NULL REFERENCES items(id) ON DELETE RESTRICT,
    link_type   TEXT NOT NULL,                          -- registry-validated at write time
    created_at  TEXT NOT NULL,
    metadata    TEXT,                                   -- optional JSON (iteration counters, etc.)
    PRIMARY KEY (source_id, target_id, link_type),
    CHECK (source_id != target_id),
    CHECK (length(link_type) <= 64)
);

CREATE INDEX ix_links_target ON item_links(target_id, link_type);
CREATE INDEX ix_links_source ON item_links(source_id, link_type);
```

**Cardinality enforcement** via per-link-type partial unique indexes, generated from pack declarations at init time:

```sql
-- Each many_to_one or one_to_one link type gets its own index.
-- Generated by the registry when packs are loaded, not hardcoded in schema.
-- Example for built-in link types:
CREATE UNIQUE INDEX ix_links_parent_singular
    ON item_links(source_id) WHERE link_type = 'parent';
CREATE UNIQUE INDEX ix_links_goal_singular
    ON item_links(source_id) WHERE link_type = 'goal';
CREATE UNIQUE INDEX ix_links_cycle_singular
    ON item_links(source_id) WHERE link_type = 'cycle';
CREATE UNIQUE INDEX ix_links_stream_singular
    ON item_links(source_id) WHERE link_type = 'stream';
-- many_to_many types (blocks, relates) get NO singular index.
```

The registry is the source of truth for cardinality. When packs declare a new `many_to_one` link type, a corresponding unique index is created. When packs declare `many_to_many`, no index is generated. This avoids the synchronization problem of a single hardcoded exclusion list and keeps pack extensibility intact without schema migrations.

### 1.3 Convenience Views

```sql
CREATE VIEW v_parent AS
    SELECT source_id AS child_id, target_id AS parent_id, created_at
    FROM item_links WHERE link_type = 'parent';

CREATE VIEW v_blocks AS
    SELECT source_id AS blocker_id, target_id AS blocked_id, created_at
    FROM item_links WHERE link_type = 'blocks';

CREATE VIEW v_containers AS
    SELECT source_id AS item_id, target_id AS container_id, link_type AS container_role, created_at
    FROM item_links WHERE link_type IN ('goal', 'cycle', 'stream');
```

**Invariant**: The three universal role names (`goal`, `cycle`, `stream`) are fixed at the link-type layer and never renamed. Packs provide display labels only (e.g., "Milestone" for `goal`). Convenience views, CLI flags (`--goal`, `--cycle`, `--stream`), and API parameters use these universal names. If a future container role is needed, it is added to this fixed set — not invented per-pack.

### 1.4 Supporting Tables

Labels, comments, events, and FTS tables remain structurally similar to v1 but reference `items` instead of `issues`. The events table gains link event types: `link_created`, `link_removed`, `link_reassigned`.

**Tables requiring `rebuild_table()` migration** (SQLite cannot rename FK targets in-place):

| Table | Current FK | Change | Complexity |
|-------|-----------|--------|------------|
| `events` | `issue_id TEXT NOT NULL REFERENCES issues(id)` | Rename column + rebuild dedup unique index | Medium — audit trail is load-bearing |
| `comments` | `issue_id TEXT NOT NULL REFERENCES issues(id)` | Rename column | Low |
| `labels` | `issue_id TEXT NOT NULL REFERENCES issues(id)` | Rename column | Low |
| `file_associations` | `issue_id TEXT NOT NULL REFERENCES issues(id)` | Rename column; generalize `assoc_type` CHECK constraint | Medium — `NOT NULL` requires `rebuild_table()` |
| `scan_findings` | `issue_id TEXT REFERENCES issues(id) ON DELETE SET NULL` | Rename column; nullable so simpler migration | Low |
| `issues_fts` (FTS5) | `content='issues'` | DROP + CREATE as `items_fts` with `content='items'`; rewrite 3 triggers | Medium |

**`file_associations.assoc_type`**: The current CHECK constraint (`bug_in`, `task_for`, `scan_finding`, `mentioned_in`) embeds software-domain vocabulary. For domain-agnostic v2, generalize to `linked_to` (replaces `bug_in`/`task_for`) while preserving `scan_finding` and `mentioned_in`. Validate via registry rather than CHECK constraint, consistent with `link_type` validation strategy.

**Code modules impacted**: `db_files.py` (1,218 lines) and `mcp_tools/files.py` (539 lines) use `issue_id` throughout and are not mechanical renames.

---

## 2. Template System Extensions

### 2.1 Link Type Declarations

Packs declare link types with structural metadata:

```json
"link_types": {
  "parent": {
    "display_name": "Parent",
    "cardinality": "many_to_one",
    "inverse_name": "Children",
    "valid_pairs": [
      {"source": ["task", "bug"], "target": ["phase", "epic"]},
      {"source": ["phase"], "target": ["milestone"]}
    ],
    "cycle_check": true
  },
  "blocks": {
    "display_name": "Blocks",
    "cardinality": "many_to_many",
    "inverse_name": "Blocked by",
    "valid_pairs": "any",
    "cycle_check": true
  }
}
```

**Cardinality options**: `many_to_one` (container/parent semantics), `many_to_many` (dependency/relation semantics), `one_to_one` (rare, e.g., postmortem-to-incident).

**`cycle_check`**: Enables topological cycle detection at write time. Essential for `parent` and `blocks`; unnecessary for container roles. When enabled, `_would_create_cycle()` must accept a `link_type` parameter and filter `item_links WHERE link_type = ?` in its BFS — cross-link-type paths must not trigger false positives.

Cycle detection semantics per link type:
- `parent`, `blocks`: Cycles absolutely forbidden (topological ordering required)
- `relates`: Cycles permitted (A relates-to B relates-to A is valid)
- Container roles (`goal`, `cycle`, `stream`): Cycles structurally impossible (cardinality prevents them)

**`valid_pairs`**: Array of source/target type constraints. `"any"` disables type checking. Validated on link creation.

**Link type creation**: The schema stores `link_type` as free text, but the CLI and dashboard must present link types as a closed picker derived from the registry. Free-text creation is blocked at the application layer to prevent typos that are syntactically valid and semantically dead.

### 2.2 Link-Aware Transition Gates

Transitions can declare gates that evaluate against the item's link topology:

```json
"transitions": {
  "publish": {
    "from": ["locked"],
    "enforcement": "hard",
    "gates": [{
      "link_type": "cycle",
      "direction": "inbound",
      "condition": "all_in_category",
      "params": {"category": ["done"]},
      "message": "All pieces must be published or spiked before edition publishes"
    }]
  }
}
```

**Supported gate conditions:**

| Condition | Params | Semantics |
|-----------|--------|-----------|
| `all_in_category` | `category: [str]` | Every linked item's status is in one of the named categories |
| `none_in_category` | `category: [str]` | No linked item is in any of the named categories |
| `all_in_state` | `states: [str]` | Every linked item's status is in one of the named states |
| `any_in_state` | `states: [str]` | At least one linked item is in one of the named states |
| `count_gte` | `n: int` | At least N items linked via this type |
| `count_eq` | `n: int` | Exactly N items linked |
| `all_field_set` | `field: str` | Every linked item has the named field populated |

Gates inherit the transition's `enforcement` level (hard = reject, soft = warn). `direction`: `inbound` = items linking TO me, `outbound` = items I link TO. Multiple gates on one transition use AND semantics.

### 2.3 Universal Container Roles

Three universal container role names with pack-specific display labels:

| Role | Question it Answers | Software | Editorial | Clinical |
|------|-------------------|----------|-----------|----------|
| **Goal** | "What are we achieving?" | Milestone | Series | Study |
| **Cycle** | "What bounded output?" | Release | Edition | Protocol Version |
| **Stream** | "What cross-cutting theme?" | Epic | Beat | Therapeutic Area |

Pack declaration:
```json
"role_labels": {
  "goal":   {"display_name": "Milestone", "icon": "flag",    "color": "blue"},
  "cycle":  {"display_name": "Release",   "icon": "package", "color": "green"},
  "stream": {"display_name": "Epic",      "icon": "layers",  "color": "purple"}
}
```

The query engine, CLI, and API use universal role names (`--goal`, `--cycle`, `--stream`). The dashboard displays pack-specific labels.

### 2.4 Pack-Declared Visual Metadata

Types declare their own visual identity:
```json
"types": {
  "piece": {
    "display_name": "Piece",
    "icon": "file-text",
    "color": "amber",
    "graph_shape": "rectangle",
    ...
  }
}
```

The dashboard reads these from the API — no hardcoded type-to-icon mappings.

### 2.5 Pack-Declared View Defaults

```json
"views": {
  "default": "calendar",
  "available": ["calendar", "kanban", "list", "timeline"],
  "calendar_axis": "due_at",
  "group_by": "stream"
}
```

Bounded menu: `list | kanban | calendar | timeline`. Packs declare which is default and how axes map. No arbitrary widget plugin API.

### 2.6 State Categories

Gate conditions that reference "categories" (`all_in_category`, `none_in_category`) require a formal mapping from states to categories. Each state in a type template declares its category:

```json
"states": {
  "assigned":  {"category": "open",  "display_name": "Assigned"},
  "drafting":  {"category": "wip",   "display_name": "Drafting"},
  "published": {"category": "done",  "display_name": "Published"},
  "spiked":    {"category": "done",  "display_name": "Spiked"}
}
```

**Built-in categories** (universal across all packs):

| Category | Semantics | Used By |
|----------|-----------|---------|
| `open` | Not started | Ready/blocked queries, triage panel |
| `wip` | In progress | WIP limits, progress indicators |
| `done` | Terminal or resolved | Gate conditions, completion checks, Andon Cord |

Categories are declared per-state, per-type. The engine uses categories for aggregate queries (e.g., "are all linked items done?") while gates that need exact state matching use `all_in_state` / `any_in_state` instead.

---

## 3. UX Design

### 3.1 Progressive Structure

The dashboard UI starts minimal and grows with the project:
- **5 items**: Flat priority-sorted list. No Kanban, no filters.
- **First container created**: Corresponding sidebar section appears with tooltip explanation.
- **50 items**: System suggests switching to Kanban view.
- **200 items**: Container pages become primary navigation; global list becomes search/filter.

### 3.2 Three-Tier Andon Cord

Unanchored items (no Goal, no Cycle, no Stream) are surfaced with graduated friction:

1. **Permanent "Triage" panel** — Always visible in sidebar with count badge. Items linked to closed containers also surface here.
2. **Soft nudge at creation** — When unanchored items exceed configurable threshold (default: 10% of active items), new item creation shows interstitial: "You have N unanchored items. Assign one first?"
3. **Hard gate at close** — Terminal states (`published`, `completed`, etc.) require at least one container link. Pack-configurable.

Principle: *"Creating items is frictionless (ideas are cheap). Closing items requires completeness (quality matters at delivery)."*

### 3.3 Domain-Specific Views

- **Software projects**: Kanban default, grouped by status categories (open/wip/done).
- **Editorial projects**: Calendar default, with pieces on publication dates, series as color-coded swim lanes, empty slots as dashed placeholders.
- **Event projects**: Timeline default, sorted by due date, grouped by workstream.

### 3.4 Terminology

- "Item" as universal base term in UI, API, CLI, database
- Pack-specific display terms via `role_labels` and type `display_name`
- One bridge sentence in pack docs: *"In filigree, everything is an item. In content publishing, items are called pieces."*

---

## 4. Exemplar Pack: Content Publishing (Editorial)

### 4.1 Types

| Type | Role | States |
|------|------|--------|
| `pitch` | Story proposal | submitted → evaluating → approved / killed |
| `piece` | Assigned content | assigned → drafting → filed → editing → ready → published / spiked |
| `revision` | Editorial feedback round | requested → in_progress → resolved / waived |
| `series` | Goal container | planning → active → complete / cancelled |
| `publication_target` | Cycle container | planning → accepting → locked → published |

### 4.2 Container Role Labels

```json
"role_labels": {
  "goal":   {"display_name": "Series",  "icon": "book-open", "color": "amber"},
  "cycle":  {"display_name": "Edition", "icon": "calendar",  "color": "teal"},
  "stream": {"display_name": "Beat",    "icon": "tag",       "color": "rose"}
}
```

### 4.3 Key Transition Gates

- **Piece → ready**: All child revisions must be resolved or waived (inbound parent gate, `all_in_category: [done]`)
- **Edition → locked**: All assigned pieces must be at least in progress (`all_in_category: [wip, done]`)
- **Edition → published**: All assigned pieces must be published or spiked (`all_in_state: [published, spiked]`)
- **Series → active**: At least one piece assigned (`count_gte: 1`)
- **Series → complete**: All assigned pieces must be done (`all_in_category: [done]`)

### 4.4 Drifting Goals Encoding

The editorial pack structurally encodes resistance to the "Drifting Goals" archetype (quality erosion under volume pressure):

- The `review` state is non-skippable for pieces assigned to a public-facing Stream. `drafting → published` is not a valid transition.
- A "Review Queue Depth" ratio (items in drafting vs items in review) surfaces as a dashboard metric. When it exceeds 3:1, a warning surfaces.
- Quality standards belong to the Stream (topic vertical), not the Cycle (deadline). The separation prevents weekly deadlines from eroding series standards.

---

## 5. Scope Decisions

### 5.1 In Scope for filigree-next

| Feature | Form |
|---------|------|
| Unified `item_links` model | Core schema |
| Link-aware transition gates | Template system extension |
| Goal/Cycle/Stream universal roles | Template system + CLI + dashboard |
| Progressive Structure UI | Dashboard redesign |
| Three-tier Andon Cord | Dashboard feature |
| `due_at` field + dashboard warnings | Column + UI |
| Pack-declared visual metadata | Template + dashboard |
| Bounded view menu | Dashboard feature |
| Editorial exemplar pack | Built-in pack |
| Link events in audit trail | Events system extension |
| "Item" terminology throughout | Full rename |

### 5.2 Deferred

| Feature | Reason |
|---------|--------|
| Composite entities | Parent_id trees are a workable model |
| Concurrent sub-states | Linked items are a clean workaround |
| Auto-transitions (time-driven) | No daemon architecture; `due_at` + warnings covers 90% |
| Arbitrary dashboard widget API | Bounded view menu is sufficient |

### 5.3 Out of Scope

| Feature | Reason |
|---------|--------|
| HR/Recruiting pipeline | Architectural mismatch — tracks people, not work items |
| Real-time operational workflows | State machine targets human-driven sequential workflows |
| Multi-user permissions / RBAC | Separate concern; not part of workflow extensibility |

---

## 6. Implementation Scope

### 6.1 Code Surface Area

~70+ files total: ~20 Python source files with substantive changes, ~14 JS files, ~14 test files (24,550 lines), plus CLAUDE.md and hook scripts. Fresh schema — migration tooling ships separately (see Section 7).

| Module | Impact | Nature |
|--------|--------|--------|
| `core.py` | Heavy | Schema rewrite, `Item` dataclass (was `Issue`), cardinality index generation |
| `db_items.py` (new, replaces `db_issues.py`) | Heavy | All CRUD rewrites, unified link handling |
| `db_links.py` (new `LinksMixin`) | Heavy | Link CRUD, cardinality validation, cycle detection |
| `db_planning.py` | Heavy | `create_plan()` rewrite (not mechanical — hardcodes `milestone`/`phase`/`step`); link-type-scoped ready/blocked/critical-path queries |
| `db_workflow.py` | Medium | New `_validate_link_target()` replaces parent-specific validation; gate evaluator (~200-300 lines of new code) |
| `templates.py` | Medium | Add icon/color/graph_shape to TypeTemplate; link type declarations; state category model |
| `templates_data.py` | Medium | All pack definitions updated; editorial pack added |
| `db_files.py` | Medium | `issue_id` -> `item_id` throughout (1,218 lines); `assoc_type` vocabulary change |
| `cli_commands/` (6 files) | Medium | Rename commands, add `--goal`/`--cycle`/`--stream` flags |
| `mcp_tools/` (6 files) | API-breaking | Tool and parameter renames — external surface consumed by AI agents and scripts |
| `dashboard.py` | Medium | Route renames, link-aware API endpoints |
| `static/js/` (14 files) | Medium | Data-driven type visuals from pack metadata; remove hardcoded `TYPE_ICONS`/`TYPE_COLORS`/shape logic |
| `tests/` (14 files) | Heavy | Full test suite rewrite — all tests use `create_issue()`, `Issue` dataclass, `issues` table assertions |

### 6.2 What Gets Simpler

- `_build_issues_batch()` — 6-7 batched queries consolidate to ~4 (labels remain separate; link queries merge by type filter but don't fully collapse)
- CRUD — one validation pattern instead of three (parent, deps, containers)
- Planning queries — unified link-type-filtered queries
- Dashboard graph — one query returns all edge types

### 6.3 What Gets Harder

- Cycle detection must be link-type-scoped — `_would_create_cycle(link_type)` filters `item_links WHERE link_type = ?` in BFS. Without this, a `blocks` path between two items would prevent a valid `parent` link (correctness bug)
- "Get all children" becomes a JOIN table lookup (negligible at filigree scale)
- Gate evaluator is ~200-300 lines of new Python with no current analog — each condition requires a query against `item_links` joined to `items`. Needs its own dedicated test surface
- Per-link-type cardinality indexes must be generated from registry at init time (see Section 1.2)

### 6.4 Tracer Bullet Milestone

Before implementing all in-scope features, define an internal v2.0-alpha checkpoint:

1. `items` table + `item_links` table as bare schema
2. One link type (`blocks`) with cardinality enforcement and cycle detection
3. `filigree create` / `filigree list` / `filigree add-dep` working end-to-end
4. One CLI round-trip proving the registry validates link types at write time

This validates the core integration assumptions before building gate conditions, editorial pack, Progressive Structure, and Andon Cord on top. Without it, the first integration test is "all 70+ files working together" — a very late feedback loop for a solo developer.

---

## 7. Open Items for Implementation Planning

| Item | Priority | Notes |
|------|----------|-------|
| Link event semantics specification | Must-have | Define `link_created`, `link_removed`, `link_reassigned` event shapes; without this, events table schema is undefined |
| Container closure orphan recovery | Must-have | Items pointing at closed containers surface in Triage; specify the recovery flow (reassign to open container, or unlink + allow close) |
| Search specification (FTS5) | Must-have | Which fields indexed, FTS5 table rename requires DROP + CREATE + data re-index + 3 trigger rewrites — deeper than a one-liner |
| View query mapping | Must-have | How pack-declared views map to queries; without this, dashboard cannot render any pack-specific view |
| Migration tooling from v1 | Should-have | One-time script (~50 lines): `issues`→`items`, `dependencies`→`item_links WHERE link_type='blocks'`, `parent_id`→`item_links WHERE link_type='parent'`. Do before cutover — the developer uses filigree to track filigree-next's own development |
| Error message vocabulary per link type | Should-have | Pack-declared user-facing messages for constraint violations; machine-readable error codes |
| Bulk operations on item_links | Should-have | Multi-select container reassignment |
| View state persistence | Should-have | Per-project user view preferences |

---

## 8. Documentation Architecture

### 8.1 Core Docs (Domain-Neutral)

1. What filigree is (1 paragraph)
2. Your first item (5-minute hands-on)
3. How items connect (one concept, three examples)
4. Organizing with packs (what packs are, how to choose)
5. Quick reference (CLI cheatsheet, glossary)

### 8.2 Pack Guides (Identical Structure)

1. Who this is for (1 paragraph)
2. Your item types (table)
3. How work flows (state diagram + walkthrough)
4. Worked example (realistic mini-project)
5. Quick reference (type + state cheatsheet)

### 8.3 Terminology Rule

"Item" in core docs. Domain term in pack docs with one bridge sentence. CLI and API always use "item."

---

## 9. Registry API Contract

Pack authors need a clear contract for what must be declared. This section specifies the minimal complete declaration for each registry concept.

### 9.1 Type Declaration (required)

```json
{
  "display_name": "Piece",
  "icon": "file-text",
  "color": "amber",
  "graph_shape": "rectangle",
  "states": {
    "assigned":  {"category": "open"},
    "drafting":  {"category": "wip"},
    "published": {"category": "done"}
  },
  "transitions": { ... },
  "fields": { ... }
}
```

Required fields: `display_name`, `states` (each with `category`), `transitions`.
Optional fields: `icon`, `color`, `graph_shape`, `fields`.

### 9.2 Link Type Declaration (required if pack uses links)

```json
{
  "display_name": "Blocks",
  "cardinality": "many_to_many",
  "inverse_name": "Blocked by",
  "valid_pairs": "any",
  "cycle_check": true
}
```

Required fields: `display_name`, `cardinality`, `cycle_check`.
Optional fields: `inverse_name`, `valid_pairs` (defaults to `"any"`).

### 9.3 Role Labels (optional)

```json
{
  "goal":   {"display_name": "Milestone", "icon": "flag",    "color": "blue"},
  "cycle":  {"display_name": "Release",   "icon": "package", "color": "green"},
  "stream": {"display_name": "Epic",      "icon": "layers",  "color": "purple"}
}
```

Packs that don't use containers omit this entirely. Partial declarations are valid (e.g., declare only `goal` if the domain doesn't use cycles or streams).

### 9.4 Error Model

Constraint violations produce machine-readable error codes with pack-overridable messages:

| Code | Default Message | Pack Override Key |
|------|----------------|-------------------|
| `LINK_CYCLE` | "Would create a cycle in {link_type} graph" | `errors.link_cycle` |
| `LINK_CARDINALITY` | "Item already has a {link_type} link" | `errors.link_cardinality` |
| `LINK_INVALID_PAIR` | "{source_type} cannot link to {target_type} via {link_type}" | `errors.link_invalid_pair` |
| `GATE_FAILED` | Gate's `message` field | Per-gate `message` |
| `LINK_TARGET_NOT_FOUND` | "Target item {id} not found" | `errors.link_target_not_found` |

### 9.5 Format Conventions

| Field | Format | Enforcement |
|-------|--------|-------------|
| `due_at`, `created_at`, `updated_at`, `closed_at` | ISO 8601 UTC (`2026-03-15T00:00:00Z`) | Write-layer validation; SQLite stores as TEXT |
| `fields` JSON | Sorted keys, no trailing whitespace | Write-layer normalization for stable diffs |
| `metadata` JSON on `item_links` | Free-form; not indexed or queried | Application-layer only; promote to columns if queryable |
| `id` | 10-character hex (`filigree-{10hex}`) | Generated at creation time |

---

## Appendix: Discussion Provenance

This design emerged from a 5-round facilitated discussion with 6 specialist agents:

| Agent | Expertise | Key Contributions |
|-------|-----------|-------------------|
| sdlc-engineer | Process design | Universal container vocabulary (Goal/Cycle/Stream), editorial pack, link-aware gate design |
| systems-thinker | Systems dynamics | Andon Cord mechanism, missing primitives ranking, Drifting Goals encoding, cardinality verdict |
| arch-critic | Architecture critique | Unified link table proposal, RESTRICT verdict, schema critique, missing primitives identification |
| codebase-explorer | Codebase archaeology | Feasibility assessment, code scope estimate, pack relationship metadata discovery |
| ux-designer | UX design | Progressive Structure, persona analysis, bounded view menu, "item" recommendation |
| doc-writer | Documentation quality | Teachability assessment, documentation architecture, terminology architecture |

Full transcript: [2026-02-25-workflow-discussion-transcript.md](./2026-02-25-workflow-discussion-transcript.md)

Post-design review (3 specialist agents + 1 external reviewer): [2026-02-25-workflow-review-annex.md](./2026-02-25-workflow-review-annex.md)
